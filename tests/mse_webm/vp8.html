<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
    <title>MediaSource API Demo (test vp8)</title>
</head>
<body>

<h3>Testing VP8 codec</h3>

<section>
    <video controls autoplay width="320" height="240"></video>
    <p>permalink: <a id="permalink" href=""></a></p>
    <p><pre id="log"></pre></p>
</section>

<script>
    function Logger(id) {
        this.el = document.getElementById('log');
    }
    var log_start = Date.now();
    Logger.prototype.log = function(msg) {
        var fragment = document.createDocumentFragment();
        fragment.appendChild(document.createTextNode((Date.now() - log_start) + ': ' + msg));
        fragment.appendChild(document.createElement('br'));
        this.el.appendChild(fragment);
    };

    Logger.prototype.clear = function() {
        this.el.textContent = '';
    };

    var logger = new Logger('log');
    logger.log('Log: (times in ms)');
</script>
<script>
function parseSearch(search) {
    var params = {};
    if (search.length > 1 && search[0] == '?') {
        search = search.substring(1);
        params = JSON.parse(
                '{"' + search.replace(/&/g, '","').replace(/=/g, '":"') + '"}',
                function (key, value) {
                    return key === "" ? value : decodeURIComponent(value)
                }
        );
    }
    return params;
}

var params = parseSearch(window.location.search);

var FILE = params['file'] || 'seek.webm';
logger.log('file=' + FILE);

var MIME = params['mime'] || 'video/webm';
logger.log('mime=' + MIME);
var CODECS = params['codecs'] || 'vp8';
logger.log('codecs=' + CODECS);

var NUM_CHUNKS = params['chunks'] || 2;
logger.log('chunks=' + NUM_CHUNKS + ' (number of chunks to divide the file into)');

var EOS_CHUNK = params['eos_chunk'] || NUM_CHUNKS;
logger.log('eos_chunk=' + EOS_CHUNK + ' (1..chunks: chunk# at which mediaSource.endOfStream() is called; use 0 for no call)');

var EOS_DELAY = params['eos_delay'] || -1;
logger.log('eos_delay=' + EOS_DELAY + ' (delay in ms between last appendBuffer and endOfStream, -1 to wait for updateend, -x to wait x ms after updateend)');

var DELAY_CHUNK = params['delay_chunk'] || 0;
logger.log('delay_chunk=' + DELAY_CHUNK + ' (delay in ms between reading each chunk)');

var START = params['start'] || -1;
logger.log('start=' + START + ' (start playing time, -1 for none)');

var SIZE = params['size'] || 318;

var ABORT = params['abort'] || -1;

var OFFSET = [ SIZE / 2, SIZE, -1 ];

var permalink = document.getElementById('permalink');
permalink.href =
        window.location.protocol
        + '//' + window.location.host
        + window.location.pathname
        + '?'
        + 'chunks=' + encodeURIComponent(NUM_CHUNKS)
        + '&eos_chunk=' + encodeURIComponent(EOS_CHUNK)
        + '&eos_delay=' + encodeURIComponent(EOS_DELAY)
        + '&delay_chunk=' + encodeURIComponent(DELAY_CHUNK)
        + '&start=' + encodeURIComponent(START)
        + '&size=' + encodeURIComponent(SIZE)
        + '&abort=' + encodeURIComponent(ABORT)
;
permalink.textContent = permalink.href;

var video = document.querySelector('video');
video.addEventListener('loadstart', function(e){ logger.log('video.loadstart'); });
video.addEventListener('progress', function(e){ logger.log('video.progress'); });
video.addEventListener('suspend', function(e){ logger.log('video.suspend'); });
video.addEventListener('abort', function(e){ logger.log('video.abort'); });
video.addEventListener('error', function(e){ logger.log('video.error'); });
video.addEventListener('emptied', function(e){ logger.log('video.emptied'); });
video.addEventListener('stalled', function(e){ logger.log('video.stalled'); });
video.addEventListener('loadedmetadata', function(e){ logger.log('video.loadedmetadata'); logger.log('video.height=' + video.videoHeight); logger.log('video.width=' + video.videoWidth); logger.log('video.duration=' + video.duration); logger.log('mediasource.duration = ' + mediaSource.duration); });
video.addEventListener('canplay', function(e){ logger.log('video.canplay'); });
video.addEventListener('canplaythrough', function(e){ logger.log('video.canplaythrough'); });
video.addEventListener('playing', function(e){ logger.log('video.playing'); });
video.addEventListener('waiting', function(e){ logger.log('video.waiting'); });
video.addEventListener('seeking', function(e){ logger.log('video.seeking'); });
video.addEventListener('seeked', function(e){ logger.log('video.seeked'); });
video.addEventListener('ended', function(e){ logger.log('video.ended'); });
video.addEventListener('durationchange', function(e){ logger.log('video.durationchange'); logger.log('video.duration=' + video.duration); logger.log('mediasource.duration = ' + mediaSource.duration); });
//video.addEventListener('timeupdate', function(e){ logger.log('video.timeupdate '); });
video.addEventListener('play', function(e){ logger.log('video.play'); });
video.addEventListener('pause', function(e){ logger.log('video.pause'); });
video.addEventListener('ratechange', function(e){ logger.log('video.ratechange'); });
video.addEventListener('resize', function(e){ logger.log('video.resize'); });
video.addEventListener('volumechange', function(e){ logger.log('video.volumechange'); });

video.addEventListener('loadeddata', function(e){
    logger.log('video.loadeddata');
    if (START >= 0) {
        video.currentTime = START;
    }
});

if (!!!window.MediaSource) {
    logger.log('MediaSource API is not available');
}

if (MediaSource.isTypeSupported("video/webm; codecs=vp8")) {
  logger.log("VP8 MSE is always supported");
} else {
  logger.log("No VP8");
}

</script>
</body>
</html>
